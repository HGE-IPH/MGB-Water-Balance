# -*- coding: utf-8 -*-
"""
/***************************************************************************
 BalancoHidrico
                                 A QGIS plugin
 Esse plugin realiza o balanço hídrico de simualções do MGB.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2021-03-05
        git sha              : $Format:%H$
        copyright            : (C) 2021 by Rafaela Oliveira
        email                : rafinhamoz@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import sys

import numpy as np    
import math
import datetime
import time
from datetime import datetime,timedelta

from qgis.core import (
    QgsMessageLog,
    QgsGeometry,
)

from qgis.gui import (
    QgsMessageBar,
)

from qgis.PyQt.QtWidgets import (
    QSizePolicy,
    QPushButton,
    QDialog,
    QGridLayout,
    QDialogButtonBox,
)
from PyQt5.QtCore import QSettings, QTranslator, qVersion, QCoreApplication, pyqtSlot
from PyQt5.QtCore import QSettings, QTranslator, QVersionNumber, QCoreApplication, Qt, QObject, pyqtSignal 
from PyQt5.QtGui import QIcon
from PyQt5.QtWidgets import *

from qgis.gui import *
from qgis.core import *

from qgis.utils import iface
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, Qt
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction
from .resources import *

import matplotlib.pyplot as plt
import matplotlib.image as mpimg
from matplotlib.pyplot import figure

# Import the code for the DockWidget
from .mgb_water_balance_dockwidget import MGBWaterBalanceDockWidget

import os.path
import os
import shutil
import subprocess

import math

from PyQt5.QtWidgets import *
from PyQt5.QtCore import QSettings, QTranslator, QVersionNumber, QCoreApplication, Qt, QObject, pyqtSignal

os.chdir(os.path.dirname(__file__))


#class BalancoHidrico:
class MGBWaterBalance:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        
        self.iface = iface
        self.dockwidget = MGBWaterBalanceDockWidget()
        self.plugin_dir = os.path.dirname(__file__)
        self.toolbar = self.iface.addToolBar('MGBWaterBalance')  
        self.toolbar.setObjectName('MGBWaterBalance')
        self.pluginIsActive = False

        self.dockwidget.pushButton_4.clicked.connect(self.selectOutputDir_qs)
        self.dockwidget.pushButton.clicked.connect(self.input)
        self.dockwidget.pushButton_2.clicked.connect(self.input1)
        self.dockwidget.pushButton_5.clicked.connect(self.somatorio_qs)
        self.dockwidget.pushButton_3.clicked.connect(self.input2)

        self.dockwidget.pushButton_6.clicked.connect(self.input3)

        self.dockwidget.pushButton_9.clicked.connect(self.input4)
        
        
        self.dockwidget.pushButton_7.clicked.connect(self.graphev)
        self.dockwidget.pushButton_8.clicked.connect(self.graphprec)
        self.dockwidget.pushButton_10.clicked.connect(self.graphesc)
        self.dockwidget.pushButton_11.clicked.connect(self.graphds)
        
              
        self.dockwidget.radioButton_2.toggled.connect(self.dockwidget.lineEdit_5.setEnabled)
        self.dockwidget.radioButton_2.toggled.connect(self.dockwidget.lineEdit.setEnabled)
        self.dockwidget.radioButton_2.toggled.connect(self.dockwidget.lineEdit_7.setEnabled)
        self.dockwidget.radioButton_2.toggled.connect(self.dockwidget.lineEdit_2.setEnabled)
        self.dockwidget.radioButton_2.toggled.connect(self.dockwidget.lineEdit_3.setEnabled)
        
        self.dockwidget.radioButton.toggled.connect(self.dockwidget.lineEdit_5.setDisabled)
        self.dockwidget.radioButton.toggled.connect(self.dockwidget.lineEdit.setDisabled)
        self.dockwidget.radioButton.toggled.connect(self.dockwidget.lineEdit_7.setDisabled)
        self.dockwidget.radioButton.toggled.connect(self.dockwidget.lineEdit_2.setDisabled)
        self.dockwidget.radioButton.toggled.connect(self.dockwidget.lineEdit_3.setDisabled)

        self.dockwidget.radioButton.setChecked(True)



        os.chdir('C:')
        self.dir = 'C:/'
        self.plugdir = os.path.dirname(__file__)
        for i in self.plugdir:
            if i == '\\':
                self.plugdir = self.plugdir.replace('\\', '/')


    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        self.action = QAction(QIcon(self.plugdir + '/icon.png'), 'MGB Water Balance', self.iface.mainWindow())
        self.action.triggered.connect(self.run)
        self.iface.addToolBarIcon(self.action)
        self.iface.addPluginToMenu('&IPH - Plugins', self.action)


    def onClosePlugin(self):

        self.dockwidget.closingPlugin.disconnect(self.onClosePlugin)

        self.pluginIsActive = False
 
    def unload(self):

        self.iface.removePluginMenu('&Balanço Hídrico', self.action)
        self.iface.removeToolBarIcon(self.action)
      
    def input(self):

        name = QFileDialog.getOpenFileName(parent=self.dockwidget, caption='Input', filter='PBI Files (*.pbi)', directory=self.dir)
        name=name[0]
        
        self.dir = os.path.dirname(name) + '/'

        for i in name:
            if i == '\\':
                name = name.replace('\\', '/')

        self.dockwidget.lineEdit.setText(name)
    
    def input1(self):

        name1 = QFileDialog.getOpenFileName(parent=self.dockwidget, caption='Input', filter='MGB Files (*.MGB)', directory=self.dir)
        name1=name1[0]
        
        self.dir = os.path.dirname(name1) + '/'

        for i in name1:
            if i == '\\':
                name1 = name1.replace('\\', '/')

        self.dockwidget.lineEdit_2.setText(name1)
        
    def input2(self):

        name = QFileDialog.getOpenFileName(parent=self.dockwidget, caption='Input', filter='MGB Files (*.MGB)', directory=self.dir)
        name=name[0]
        
        self.dir = os.path.dirname(name) + '/'

        for i in name:
            if i == '\\':
                name = name.replace('\\', '/')

        self.dockwidget.lineEdit_3.setText(name)
        
    def input3(self):

        name = QFileDialog.getOpenFileName(parent=self.dockwidget, caption='Input', filter='MGB Files (*.sim)', directory=self.dir)
        name=name[0]
        
        self.dir = os.path.dirname(name) + '/'

        for i in name:
            if i == '\\':
                name = name.replace('\\', '/')

        self.dockwidget.lineEdit_5.setText(name)
    
    def input4(self):

        name = QFileDialog.getOpenFileName(parent=self.dockwidget, caption='Input', filter='MGB Files (*.gtp)', directory=self.dir)
        name=name[0]
        
        self.dir = os.path.dirname(name) + '/'

        for i in name:
            if i == '\\':
                name = name.replace('\\', '/')

        self.dockwidget.lineEdit_7.setText(name)
    
    
    def selectOutputDir_qs(self):
            dirname = QFileDialog.getExistingDirectory(None, "Open a folder", "C://")
            
            self.dockwidget.lineEdit_4.setText(dirname)
            #inicio=self.dockwidget.lineEdit_6.text()

    def somatorio_qs(self):
        
        
        if self.dockwidget.radioButton.isChecked():

            if (self.dlg_WB.lineEdit_4.text() == ""):

                msg = QMessageBox()
                msg.setIcon(QMessageBox.Critical)
                msg.setText("Please select destination folder.")
                msg.exec_()
                return
        
                dirMGB = ('C://mgb//')
                info_tudo_mgb= (dirMGB + 'Input\infoMGB.sim')
                evapotudo_mgb= (dirMGB + 'Output\EVAPTUDO_bin.MGB')
                precipitacao_mgb=(dirMGB + 'Input\CHUVABIN.PBI')
                vazao_mgb=(dirMGB +'Output\QITUDO_bin.MGB')
                mini_mgb=(dirMGB + 'Input\MINI.gtp')
                inicio=self.dockwidget.lineEdit_6.text()
                final=self.dockwidget.lineEdit_8.text()
        
        if self.dockwidget.radioButton_2.isChecked():
            if (self.dockwidget.lineEdit_5.text() == "" and self.dockwidget.lineEdit_3.text()== ""
                and self.dockwidget.lineEdit_7.text() == "" and self.dockwidget.lineEdit.text()== ""
                 and self.dockwidget.lineEdit.text()== ""):

                msg = QMessageBox()
                msg.setIcon(QMessageBox.Critical)
                msg.setText("Please select files.")
                msg.exec_()
                return


            if (self.dockwidget.lineEdit_5.text() == ""):

                msg = QMessageBox()
                msg.setIcon(QMessageBox.Critical)
                msg.setText("Please select infoMGB.sim file.")
                msg.exec_()
                return

            if (self.dockwidget.lineEdit.text() == ""):

                msg = QMessageBox()
                msg.setIcon(QMessageBox.Critical)
                msg.setText("Please select CHUVABIN.pbi file.")
                msg.exec_()
                return

            if (self.dockwidget.lineEdit_7.text() == ""):

                msg = QMessageBox()
                msg.setIcon(QMessageBox.Critical)
                msg.setText("Please select MINI.gtp file.")
                msg.exec_()
                return

            if (self.dockwidget.lineEdit_2.text() == ""):

                msg = QMessageBox()
                msg.setIcon(QMessageBox.Critical)
                msg.setText("Please select QTUDO_bin.mgb file.")
                msg.exec_()
                return

            if (self.dockwidget.lineEdit_3.text() == ""):

                msg = QMessageBox()
                msg.setIcon(QMessageBox.Critical)
                msg.setText("Please select EVAPTUDO.mgb file.")
                msg.exec_()
                return

            if (self.dockwidget.lineEdit_4.text() == ""):

                msg = QMessageBox()
                msg.setIcon(QMessageBox.Critical)
                msg.setText("Please select destination folder.")
                msg.exec_()
                return
        
            #downDir = self.dockwidget.lineEdit.text()
            info_tudo_mgb=self.dockwidget.lineEdit_5.text()
            evapotudo_mgb=self.dockwidget.lineEdit_3.text()
            precipitacao_mgb=self.dockwidget.lineEdit.text()
            vazao_mgb=self.dockwidget.lineEdit_2.text()
            mini_mgb=self.dockwidget.lineEdit_7.text()
            inicio=self.dockwidget.lineEdit_6.text()
            final=self.dockwidget.lineEdit_8.text()
        
        #---------------------Leitura do arquivo mini.gtp----------------------------#
        
        def le_minigtp(mini_file):
            """ Le o arquivo MINI.gtp e armazena seus dados em um DataFrame """
    
        # ... leitura do arquivo "MINI.gtp"
            miniarq = open(mini_file, 'r')
            minidata = miniarq.read()
            miniarq.close()
            mini = minidata.split('\n')
    
        # .. gera listas para armazenar as informacoes de cada minibacia
            attbs = list()
            catchs = list()
            minis = list()
            xs = list()
            ys = list()
            subs = list()
            areas = list()
            uareas = list()
            rlens = list()
            rslos = list()
            alens = list()
            aslos = list()
            minijus = list()
            orders = list()
    
        # .. le o atributo CatID
            for i in range(1, len(mini)-1):
                catchs.append(int(mini[i][:8]))
    
        # .. le o atributo Mini
            for i in range(1, len(mini)-1):
                minis.append(int(mini[i][8:16]))
    
        # .. le o atributo Xcen
            for i in range(1, len(mini)-1):
                xs.append(float(mini[i][16:31]))
    
        # .. le o atributo Ycen
            for i in range(1, len(mini)-1):
                ys.append(float(mini[i][31:46]))
    
        # .. le o atributo Sub
            for i in range(1, len(mini)-1):
                subs.append(int(mini[i][46:54]))
    
        # .. le o atributo Area_(km2)
            for i in range(1, len(mini)-1):
                areas.append(float(mini[i][54:69]))
    
        # .. le o atributo AreaM_(km2)
            for i in range(1, len(mini)-1):
                uareas.append(float(mini[i][69:84]))
    
        # .. le o atributo Ltr_(km)
            for i in range(1, len(mini)-1):
                rlens.append(float(mini[i][84:99]))
    
        # .. le o atributo Str_(m/km)
            for i in range(1, len(mini)-1):
                rslos.append(float(mini[i][99:114]))
    
        # .. le o atributo Lrl_(km)
            for i in range(1, len(mini)-1):
                alens.append(float(mini[i][114:129]))
    
        # .. le o atributo Srl_(m/km)
            for i in range(1, len(mini)-1):
                aslos.append(float(mini[i][129:144]))
    
        # .. le o atributo MiniJus
            for i in range(1, len(mini)-1):
                minijus.append(int(mini[i][144:152]))
    
        # .. le o atributo Ordem
            for i in range(1, len(mini)-1):
                orders.append(int(mini[i][152:160]))
    
        # ... Armazena as informacoes de interesse em um dicionario
            mini_dict = {'Cat_ID' : catchs, 
                         'ID_Mini': minis,
                         'MiniJus': minijus,
                         'Sub'    : subs,
                         'Ordem'  : orders} # Pode-se adicionar as outras informacoes lidas do Mini.GTP seguindo a mesma logica
    
        # ... Cria uma matriz com os dados do dicionario
            df_mini = np.array(np.array(mini_dict))
            return df_mini, areas
  
    # ... aplicacao:
        df_mini, areas = le_minigtp(mini_mgb)
        areat = areas
        df_areat = np.array(np.array(areat))
        
        
    #-----soma da area total-----------#
        somaareas = np.sum(areat)
        #print ('Área total (km²):%.2f'% (somaareas))
        areas2 = np.array(areat)
        
        inicio=self.dockwidget.lineEdit_6.text()

        if inicio == "":
            msg = QMessageBox()
            msg.setIcon(QMessageBox.Critical)
            msg.setText("Please chose the period for simulation.")
            msg.exec_()
            return  
        
        final=self.dockwidget.lineEdit_8.text()
        
        if final == "":
            msg = QMessageBox()
            msg.setIcon(QMessageBox.Critical)
            msg.setText("Please chose the period for simulation.")
            msg.exec_()
            return  
        
        #------------------------ Leitura do InfoMGB.sim ------------------------------#

        def le_infotudo(info_file):
            """ Le infoMGB.sim para obter numero de minibacias (nc),
            numero de intervalos temporais (nt), tamanho do passo temporal (dt)
            e o primeiro dia de simulacao (dstart)
            """
           
            infoarq = open(info_file, 'r')
            infodata = infoarq.read()
            infoarq.close()
    
            info_temp = infodata.split('\n')
    
            # ... lendo data de inicio da simulacao
            info_date = info_temp[5]
            info_date = info_date.split(' ')
    
            lista = list()
            for i in range(len(info_date)):
                if info_date[i] == '':
                    lista.append(i)
        
            for j in reversed(lista):
                del info_date[j]
        
            dstart = datetime(int(info_date[2]), int(info_date[1]), int(info_date[0]), int(info_date[3]))
            
            # ... lendo nt e dt
            info_timestep = info_temp[8]
            info_timestep = info_timestep.split(' ')
    
            lista = list()
            for i in range(len(info_timestep)):
                if info_timestep[i] == '':
                    lista.append(i)
        
            for j in reversed(lista):
                del info_timestep[j]
        
            nt = info_timestep[0]
            dt = info_timestep[1]
            dt = dt.split(".")
            dt = dt[0]
    
            # ... lendo nc
            info_nc = info_temp[11]
            info_nc = info_nc.split(' ')
    
            lista = list()
            for i in range(len(info_nc)):
                if info_nc[i] == '':
                    lista.append(i)
        
            for j in reversed(lista):
                del info_nc[j]
        
            nc = info_nc[0]
    
            return int(nc), int(nt), int(dt), dstart

    # ... exemplo de aplicação:
        nc, nt, dt, dstart = le_infotudo(info_tudo_mgb)
        
#-------------------------- Armazenamento das datas simuladas --------------------------#

        dates = list()
        months = list()
        years = list()

        #print('Datas Simuladas:\n')
        time.sleep(3)
        for d in range(nt):
            delta = dstart + timedelta(days=d)
            year = delta.year
            month = delta.month
            years.append(year)
            months.append(month)
            dates.append(delta)
            #print('Ano: ' + str(year) + ' / Mês: ' + str(month) + ' / Data: ' + str(delta))

        dates = np.array(np.array(dates))
        #print('Período simulado: ' + str(dstart.date()) + ' - ' + str(delta.date()))
#----------- lendo o ano de início-----------------#
        h = dstart.strftime('%Y')
        hh = int(h)
        inicio2 = int(inicio)
        final2=int(final)
        i = delta.strftime('%Y')
        ii = int(i)
        k = math.floor(((inicio2-hh)/4))
        m = math.floor((final2-hh)/4)

        #--------------------hh e ii----------------#
        if (hh % 4) == 0:
            if (hh % 100) == 0:
                if (hh % 400) == 0:
                    o = 1
                else:
                    o = 0
            else:
                o = 1
        else:
            o = 0

        #------------------correto--------------#
        if (final2 % 4) == 0:
            if (final2 % 100) == 0:
                if (final2 % 400) == 0:
                    b = (((final2-hh)+1)*365)+m+o+1 #is a leap year
                else:
                    b = (((final2-hh)+1)*365)+m+o #is not a leap year
            else:
                b = (((final2-hh)+1)*365)+m+o+1 #is a leap year
        else:
            b = (((final2-hh)+1)*365)+m+o #is not a leap year
    
        if (inicio2 % 4) == 0:
            if (inicio2 % 100) == 0:
                if (inicio2 % 400) == 0:
                    f = (((inicio2-hh))*365)+k+o #is a leap year
                else:
                    f = (((inicio2-hh))*365)+k+o #is not leap year
            else:
                f = (((inicio2-hh))*365)+k+o #is a leap year
        else:
            f = (((inicio2-hh))*365)+k+o #is not leap year
   
        
   
#------------------- Leitura do arquivo de Evapotranspiração ------------------#

# ... funcao de leitura de binario

        def le_binario_mgb(filebin,nt,nc):
            """ read mgb binary files as numpy.array """
            return np.fromfile(filebin,'<f4').reshape(nt,nc)
        et = le_binario_mgb(evapotudo_mgb, nt, nc)
        evap = et
        df_evap = np.array(np.array(evap))

#------------------- Soma do arquivo de Evapotranspiração ------------------#

        #somae = np.sum(et,axis=0)
        #multiplice = [x*y for x,y in zip(areas2, somae)]
        #multiplice2 = np.array(multiplice)
        #somate = np.sum(multiplice2)
        #mediae = (somate/somaareas)
        #etano = (mediae/(nt/365))
#------------------- alterando o ano de início-------#        
        ano1e=np.delete(et,slice(b,nt,1),axis=0)
        ano1e2=np.delete(ano1e,slice(0,f,1),axis=0)
        sano1e=np.sum(ano1e2,axis=0)
        multano1e = [x*y for x,y in zip(areas2, sano1e)]
        multano1e2 = np.array(multano1e)
        sano1e2 = np.sum(multano1e2)
        me = (sano1e2/somaareas)
        etano2 = (me/((b-f)/365))

#------------------- Leitura do arquivo de Precipitação ------------------#

        # ... funcao de leitura de binario
        def le_binario_mgbp(filebin,nt,nc):
            """ read mgb binary files as numpy.array """
            return np.fromfile(filebin,'<f4').reshape(nt,nc)
        pre = le_binario_mgb(precipitacao_mgb, nt, nc)
        chuva = pre
        df_chuva = np.array(np.array(chuva))

#------------------- Soma do arquivo de Precipitação ------------------#

        #somap = np.sum(pre,axis=0)
        #multiplicp = [x*y for x,y in zip(areas2, somap)]
        #multiplicp2 = np.array(multiplicp)
        #somatp = np.sum(multiplicp2)
        #mediap = (somatp/somaareas)
        #pano = (mediap/(nt/365))
        #etpre = (etano/pano)
        
#------------------- alterando o ano de início-------#  
        ano1p=np.delete(pre,slice(b,nt,1),axis=0)
        ano1p2=np.delete(ano1p,slice(0,f,1),axis=0)
        sano1p=np.sum(ano1p2,axis=0)
        multano1p = [x*y for x,y in zip(areas2, sano1p)]
        multano1p2 = np.array(multano1p)
        sano1p2 = np.sum(multano1p2)
        mp = (sano1p2/somaareas)
        pano2 = (mp/((b-f)/365))
        etpre = (etano2/pano2)
#------------------- Leitura do arquivo de Vazão ------------------#

# ... funcao de leitura de binario
        def le_binario_mgbq(filebin,nt,nc):
            """ read mgb binary files as numpy.array """
            return np.fromfile(filebin,'<f4').reshape(nt,nc)
        qi = le_binario_mgb(vazao_mgb, nt, nc)
        vazao = qi
        df_vazao = np.array(np.array(vazao))

#------------------- Soma do arquivo de Vazão ------------------#
        #soma2 = np.sum(qi,axis=0)
        #array_length2 = len(soma2)
        #last_element2 = soma2[array_length2 -1]
        #conversaoq = ((31536*last_element2)/somaareas)
        #somaanual2 = (conversaoq/(nt/365))
        #vazpre = (somaanual2/pano)
        #dS = (pano-etano-somaanual2)
        #dSP = (dS/pano)*100
#------------------- alterando o ano de início-------#  
        ano1q=np.delete(qi,slice(b,nt,1),axis=0)
        ano1q2=np.delete(ano1q,slice(0,f,1),axis=0)
        somaq = np.sum(ano1q2,axis=0)
        array_lengthq2 = len(somaq)
        last_elementq2 = somaq[array_lengthq2 -1]
        conversaoq2 = ((31536*last_elementq2)/somaareas)
        somaanualq2 = (conversaoq2/((b-f)/365))
        vazpre = (somaanualq2/pano2)
        dS = (pano2-etano2-somaanualq2)
        dSP = (dS/pano2)*100

        downDir = self.dockwidget.lineEdit_4.text()
        
        if downDir == "":
            msg = QMessageBox()
            msg.setIcon(QMessageBox.Critical)
            msg.setText("Please chose the destination folder.")
            msg.exec_()
            return  
                

            
#------------------- Escrevendo os resultados no txt ------------------#

        arquivo = open(downDir + '/Water_balance_MGB.txt', 'w')
        arquivo.write("Water balance of the simulation performed at MGB:\n")
        arquivo.write("\n\nEvapotranspiration(mm/year):%.2f\n" % (etano2))
        arquivo.write("\nPrecipitation(mm/year):%.2f\n" % (pano2))
        arquivo.write("\nDischarge(mm/year):%.2f\n" % (somaanualq2))
        arquivo.write("\n\nSimulation information:")
        arquivo.write("\n\n\nSimulated period:" + '01-01-' + inicio + ' - ' + '31-12-' + final)
        arquivo.write("\n\nTotal area (km²):%.2f" % (somaareas))
        arquivo.write("\n\n\nRates:")
        arquivo.write("\n\n\nD/P(%%):%.2f" % (vazpre))
        arquivo.write("\n\nE/P(%%):%.2f" % (etpre))
        arquivo.write("\n\ndS(P-E-D)(mm):%.2f" % (dS))
        arquivo.write("\n\ndS/P(%%):%.2f" % (dSP))
        arquivo.write("\n\ndS:is the amount of water stored in the basin during the simulation period.")
        arquivo.write("\n\ndS/P:is the percentage of rain stored in the basin during the simulation period.")
        arquivo.close
        
  
#------------------- Plotando a imagem com os resultados ------------------#
        img = mpimg.imread(self.plugdir + '/BH.png')
        imgplot = plt.imshow(img)

        plt.axis('off') #colocar "off" para remover a grade
 
        #Textos que serão apresentados sobre a figura. Pode fazer diversos e ir encaixando na. Relacionar o texto com o resultado do balanço. 
        a = ("Precipitation(mm/year):%.2f" % (pano2))
        b = ("Evapotranspiration(mm/year):%.2f" % (etano2))
        c = ("Discharge(mm/year):%.2f" % (somaanualq2))
        d = ("Simulated period:" + '01-01-' + inicio + ' - ' + '31-12-' + final)
        e = ("Total area (km²):%.2f" % (somaareas))
        f = ("D/P(%%):%.2f" % (vazpre))    
        g = ("E/P(%%):%.2f" % (etpre))
        h = ("dS(P-E-D)(mm):%.2f" % (dS))    
        i = ("dS/P(%%):%.2f" % (dSP))        
        j = ("Water balance of the simulation performed at MGB:")
        k = ("Rates:")
        l = ("Rates:")
        m = ("Simulation information:")

        #Posições dos textos na imagem, coordenadas X e Y conforme os eixos apresentados
        plt.text(360, 380, a, ha='left', fontsize=10,  wrap=True)
        plt.text(30, 280, b, ha='left', fontsize=10, wrap=True)
        plt.text(380, 585, c, ha='left', fontsize=10,  wrap=True)
        plt.text(50, 109, m, ha='left', fontsize=9,  wrap=True)
        plt.text(50, 130, d, ha='left', fontsize=9,  wrap=True)
        plt.text(50, 151, e, ha='left', fontsize=9,  wrap=True)
        plt.text(50, 172, k, ha='left', fontsize=9,  wrap=True)
        plt.text(50, 193, f, ha='left', fontsize=9,  wrap=True)
        plt.text(50, 214, g, ha='left', fontsize=9,  wrap=True)
        plt.text(50, 781, h, ha='left', fontsize=9,  wrap=True)
        plt.text(50, 801, i, ha='left', fontsize=9,  wrap=True)
        plt.text(90, 50, j, ha='left', fontsize=12,  wrap=True)
        plt.text(50, 760, l, ha='left', fontsize=9,  wrap=True)
        #plt.savefig(downDir + '/balanco_hidrico.png')
        img = plt.get_current_fig_manager()
        img.window.showMaximized()
        plt.tight_layout()   
        #figure.set_size_inches(900,630, forward=True)
        #img.full_screen_toggle()
        #plt.figure(figsize=(3,4))
        plt.show()
        #ptl.close(img)
        
                
    def graphev(self):
        
        if self.dockwidget.radioButton.isChecked():
        
            dirMGB = ('C://mgb//')
            info_tudo_mgb= (dirMGB + 'Input\infoMGB.sim')
            evapotudo_mgb= (dirMGB + 'Output\EVAPTUDO_bin.MGB')
            precipitacao_mgb=(dirMGB + 'Input\CHUVABIN.PBI')
            vazao_mgb=(dirMGB +'Output\QITUDO_bin.MGB')
            mini_mgb=(dirMGB + 'Input\MINI.gtp')
            inicio=self.dockwidget.lineEdit_6.text()
            final=self.dockwidget.lineEdit_8.text()
        
        if self.dockwidget.radioButton_2.isChecked():
        
            #downDir = self.dockwidget.lineEdit.text()
            info_tudo_mgb=self.dockwidget.lineEdit_5.text()
            evapotudo_mgb=self.dockwidget.lineEdit_3.text()
            precipitacao_mgb=self.dockwidget.lineEdit.text()
            vazao_mgb=self.dockwidget.lineEdit_2.text()
            mini_mgb=self.dockwidget.lineEdit_7.text()
            inicio=self.dockwidget.lineEdit_6.text()
            final=self.dockwidget.lineEdit_8.text()
               
        def le_minigtp(mini_file):
            """ Le o arquivo MINI.gtp e armazena seus dados em um DataFrame """
    
        # ... leitura do arquivo "MINI.gtp"
            miniarq = open(mini_file, 'r')
            minidata = miniarq.read()
            miniarq.close()
            mini = minidata.split('\n')
    
        # .. gera listas para armazenar as informacoes de cada minibacia
            attbs = list()
            catchs = list()
            minis = list()
            xs = list()
            ys = list()
            subs = list()
            areas = list()
            uareas = list()
            rlens = list()
            rslos = list()
            alens = list()
            aslos = list()
            minijus = list()
            orders = list()
    
        # .. le o atributo CatID
            for i in range(1, len(mini)-1):
                catchs.append(int(mini[i][:8]))
    
        # .. le o atributo Mini
            for i in range(1, len(mini)-1):
                minis.append(int(mini[i][8:16]))
    
        # .. le o atributo Xcen
            for i in range(1, len(mini)-1):
                xs.append(float(mini[i][16:31]))
    
        # .. le o atributo Ycen
            for i in range(1, len(mini)-1):
                ys.append(float(mini[i][31:46]))
    
        # .. le o atributo Sub
            for i in range(1, len(mini)-1):
                subs.append(int(mini[i][46:54]))
    
        # .. le o atributo Area_(km2)
            for i in range(1, len(mini)-1):
                areas.append(float(mini[i][54:69]))
    
        # .. le o atributo AreaM_(km2)
            for i in range(1, len(mini)-1):
                uareas.append(float(mini[i][69:84]))
    
        # .. le o atributo Ltr_(km)
            for i in range(1, len(mini)-1):
                rlens.append(float(mini[i][84:99]))
    
        # .. le o atributo Str_(m/km)
            for i in range(1, len(mini)-1):
                rslos.append(float(mini[i][99:114]))
    
        # .. le o atributo Lrl_(km)
            for i in range(1, len(mini)-1):
                alens.append(float(mini[i][114:129]))
    
        # .. le o atributo Srl_(m/km)
            for i in range(1, len(mini)-1):
                aslos.append(float(mini[i][129:144]))
    
        # .. le o atributo MiniJus
            for i in range(1, len(mini)-1):
                minijus.append(int(mini[i][144:152]))
    
        # .. le o atributo Ordem
            for i in range(1, len(mini)-1):
                orders.append(int(mini[i][152:160]))
    
        # ... Armazena as informacoes de interesse em um dicionario
            mini_dict = {'Cat_ID' : catchs, 
                         'ID_Mini': minis,
                         'MiniJus': minijus,
                         'Sub'    : subs,
                         'Ordem'  : orders} # Pode-se adicionar as outras informacoes lidas do Mini.GTP seguindo a mesma logica
    
        # ... Cria uma matriz com os dados do dicionario
            df_mini = np.array(np.array(mini_dict))
            return df_mini, areas
  
    # ... aplicacao:
        df_mini, areas = le_minigtp(mini_mgb)
        areat = areas
        df_areat = np.array(np.array(areat))
        
        
    #-----soma da area total-----------#
        somaareas = np.sum(areat)
        #print ('Área total (km²):%.2f'% (somaareas))
        areas2 = np.array(areat)
        
        inicio=self.dockwidget.lineEdit_6.text()

        if inicio == "":
            msg = QMessageBox()
            msg.setIcon(QMessageBox.Critical)
            msg.setText("Please chose the period for simulation.")
            msg.exec_()
            return  
        
        final=self.dockwidget.lineEdit_8.text()
        
        if final == "":
            msg = QMessageBox()
            msg.setIcon(QMessageBox.Critical)
            msg.setText("Please chose the period for simulation.")
            msg.exec_()
            return  
        
        inicio2 = int(inicio)
        final2=int(final)
        
        def le_infotudo(info_file):
            """ Le infoMGB.sim para obter numero de minibacias (nc),
            numero de intervalos temporais (nt), tamanho do passo temporal (dt)
            e o primeiro dia de simulacao (dstart)
            """
           
            infoarq = open(info_file, 'r')
            infodata = infoarq.read()
            infoarq.close()
    
            info_temp = infodata.split('\n')
    
            # ... lendo data de inicio da simulacao
            info_date = info_temp[5]
            info_date = info_date.split(' ')
    
            lista = list()
            for i in range(len(info_date)):
                if info_date[i] == '':
                    lista.append(i)
        
            for j in reversed(lista):
                del info_date[j]
        
            dstart = datetime(int(info_date[2]), int(info_date[1]), int(info_date[0]), int(info_date[3]))
            
            # ... lendo nt e dt
            info_timestep = info_temp[8]
            info_timestep = info_timestep.split(' ')
    
            lista = list()
            for i in range(len(info_timestep)):
                if info_timestep[i] == '':
                    lista.append(i)
        
            for j in reversed(lista):
                del info_timestep[j]
        
            nt = info_timestep[0]
            dt = info_timestep[1]
            dt = dt.split(".")
            dt = dt[0]
    
            # ... lendo nc
            info_nc = info_temp[11]
            info_nc = info_nc.split(' ')
    
            lista = list()
            for i in range(len(info_nc)):
                if info_nc[i] == '':
                    lista.append(i)
        
            for j in reversed(lista):
                del info_nc[j]
        
            nc = info_nc[0]
    
            return int(nc), int(nt), int(dt), dstart

    # ... exemplo de aplicação:
        nc, nt, dt, dstart = le_infotudo(info_tudo_mgb)
        
#-------------------------- Armazenamento das datas simuladas --------------------------#

        dates = list()
        months = list()
        years = list()

        #print('Datas Simuladas:\n')
        time.sleep(3)
        for d in range(nt):
            delta = dstart + timedelta(days=d)
            year = delta.year
            month = delta.month
            years.append(year)
            months.append(month)
            dates.append(delta)
            #print('Ano: ' + str(year) + ' / Mês: ' + str(month) + ' / Data: ' + str(delta))

        dates = np.array(np.array(dates))
        #print('Período simulado: ' + str(dstart.date()) + ' - ' + str(delta.date()))
#----------- lendo o ano de início-----------------#
        h = dstart.strftime('%Y')
        hh = int(h)
        inicio2 = int(inicio)
        final2=int(final)
        i = delta.strftime('%Y')
        ii = int(i)
        k = math.floor(((inicio2-hh)/4))
        m = math.floor((final2-hh)/4)

        #--------------------hh e ii----------------#
        if (hh % 4) == 0:
            if (hh % 100) == 0:
                if (hh % 400) == 0:
                    o = 1
                else:
                    o = 0
            else:
                o = 1
        else:
            o = 0

        #------------------correto--------------#
        if (final2 % 4) == 0:
            if (final2 % 100) == 0:
                if (final2 % 400) == 0:
                    b = (((final2-hh)+1)*365)+m+o+1 #is a leap year
                else:
                    b = (((final2-hh)+1)*365)+m+o #is not a leap year
            else:
                b = (((final2-hh)+1)*365)+m+o+1 #is a leap year
        else:
            b = (((final2-hh)+1)*365)+m+o #is not a leap year
    
        if (inicio2 % 4) == 0:
            if (inicio2 % 100) == 0:
                if (inicio2 % 400) == 0:
                    f = (((inicio2-hh))*365)+k+o #is a leap year
                else:
                    f = (((inicio2-hh))*365)+k+o #is not leap year
            else:
                f = (((inicio2-hh))*365)+k+o #is a leap year
        else:
            f = (((inicio2-hh))*365)+k+o #is not leap year
   
        
   
#------------------- Leitura do arquivo de Evapotranspiração ------------------#

# ... funcao de leitura de binario

        def le_binario_mgb(filebin,nt,nc):
            """ read mgb binary files as numpy.array """
            return np.fromfile(filebin,'<f4').reshape(nt,nc)
        et = le_binario_mgb(evapotudo_mgb, nt, nc)
        evap = et
        df_evap = np.array(np.array(evap))

        t =(final2-inicio2)+1
        
        def grafico (start,end):
    
            dias=end-start
              
            anole = et[start:end]
            
            sano1e=np.sum(anole,axis=0)
            
            multanole2=areas2*sano1e
            
            sano1e2 = np.sum(multanole2)
            
            me = (sano1e2/somaareas)
            
            etano2 = (me/((dias)/365.25))
            
            return etano2

    
        arraye = []
        
        for i in range(t-1):
            
            arraye.append(grafico(f,b-(365*i)))        
            

        #------------plotando gráfico--------------#    
            
        y=[arraye]
        compe = len(arraye)
        
        x = list(range(1, t))
        
        
        # plotting points as a scatter plot
        plt.scatter(x, y, color= "blue", 
                    marker= ".", s=90)
          
        # x-axis label
        plt.xlabel('Simulation time (years)',fontsize=14)
        # frequency label
        plt.ylabel('Evapotranspiration (mm)',fontsize=14)
        #plt.legend()
        plt.yticks(fontsize=11)
        plt.xticks(fontsize=11)
        plt.show()

    def graphprec(self):
        
        if self.dockwidget.radioButton.isChecked():
        
            dirMGB = ('C://mgb//')
            info_tudo_mgb= (dirMGB + 'Input\infoMGB.sim')
            evapotudo_mgb= (dirMGB + 'Output\EVAPTUDO_bin.MGB')
            precipitacao_mgb=(dirMGB + 'Input\CHUVABIN.PBI')
            vazao_mgb=(dirMGB +'Output\QITUDO_bin.MGB')
            mini_mgb=(dirMGB + 'Input\MINI.gtp')
            inicio=self.dockwidget.lineEdit_6.text()
            final=self.dockwidget.lineEdit_8.text()
        
        if self.dockwidget.radioButton_2.isChecked():
        
            #downDir = self.dockwidget.lineEdit.text()
            info_tudo_mgb=self.dockwidget.lineEdit_5.text()
            evapotudo_mgb=self.dockwidget.lineEdit_3.text()
            precipitacao_mgb=self.dockwidget.lineEdit.text()
            vazao_mgb=self.dockwidget.lineEdit_2.text()
            mini_mgb=self.dockwidget.lineEdit_7.text()
            inicio=self.dockwidget.lineEdit_6.text()
            final=self.dockwidget.lineEdit_8.text()

        
        def le_minigtp(mini_file):
            """ Le o arquivo MINI.gtp e armazena seus dados em um DataFrame """
    
        # ... leitura do arquivo "MINI.gtp"
            miniarq = open(mini_file, 'r')
            minidata = miniarq.read()
            miniarq.close()
            mini = minidata.split('\n')
    
        # .. gera listas para armazenar as informacoes de cada minibacia
            attbs = list()
            catchs = list()
            minis = list()
            xs = list()
            ys = list()
            subs = list()
            areas = list()
            uareas = list()
            rlens = list()
            rslos = list()
            alens = list()
            aslos = list()
            minijus = list()
            orders = list()
    
        # .. le o atributo CatID
            for i in range(1, len(mini)-1):
                catchs.append(int(mini[i][:8]))
    
        # .. le o atributo Mini
            for i in range(1, len(mini)-1):
                minis.append(int(mini[i][8:16]))
    
        # .. le o atributo Xcen
            for i in range(1, len(mini)-1):
                xs.append(float(mini[i][16:31]))
    
        # .. le o atributo Ycen
            for i in range(1, len(mini)-1):
                ys.append(float(mini[i][31:46]))
    
        # .. le o atributo Sub
            for i in range(1, len(mini)-1):
                subs.append(int(mini[i][46:54]))
    
        # .. le o atributo Area_(km2)
            for i in range(1, len(mini)-1):
                areas.append(float(mini[i][54:69]))
    
        # .. le o atributo AreaM_(km2)
            for i in range(1, len(mini)-1):
                uareas.append(float(mini[i][69:84]))
    
        # .. le o atributo Ltr_(km)
            for i in range(1, len(mini)-1):
                rlens.append(float(mini[i][84:99]))
    
        # .. le o atributo Str_(m/km)
            for i in range(1, len(mini)-1):
                rslos.append(float(mini[i][99:114]))
    
        # .. le o atributo Lrl_(km)
            for i in range(1, len(mini)-1):
                alens.append(float(mini[i][114:129]))
    
        # .. le o atributo Srl_(m/km)
            for i in range(1, len(mini)-1):
                aslos.append(float(mini[i][129:144]))
    
        # .. le o atributo MiniJus
            for i in range(1, len(mini)-1):
                minijus.append(int(mini[i][144:152]))
    
        # .. le o atributo Ordem
            for i in range(1, len(mini)-1):
                orders.append(int(mini[i][152:160]))
    
        # ... Armazena as informacoes de interesse em um dicionario
            mini_dict = {'Cat_ID' : catchs, 
                         'ID_Mini': minis,
                         'MiniJus': minijus,
                         'Sub'    : subs,
                         'Ordem'  : orders} # Pode-se adicionar as outras informacoes lidas do Mini.GTP seguindo a mesma logica
    
        # ... Cria uma matriz com os dados do dicionario
            df_mini = np.array(np.array(mini_dict))
            return df_mini, areas
  
    # ... aplicacao:
        df_mini, areas = le_minigtp(mini_mgb)
        areat = areas
        df_areat = np.array(np.array(areat))
        
        
    #-----soma da area total-----------#
        somaareas = np.sum(areat)
        #print ('Área total (km²):%.2f'% (somaareas))
        areas2 = np.array(areat)
        
        inicio=self.dockwidget.lineEdit_6.text()

        if inicio == "":
            msg = QMessageBox()
            msg.setIcon(QMessageBox.Critical)
            msg.setText("Please chose the period for simulation.")
            msg.exec_()
            return  
        
        final=self.dockwidget.lineEdit_8.text()
        
        if final == "":
            msg = QMessageBox()
            msg.setIcon(QMessageBox.Critical)
            msg.setText("Please chose the period for simulation.")
            msg.exec_()
            return  
        
        inicio2 = int(inicio)
        final2=int(final)
        
        def le_infotudo(info_file):
            """ Le infoMGB.sim para obter numero de minibacias (nc),
            numero de intervalos temporais (nt), tamanho do passo temporal (dt)
            e o primeiro dia de simulacao (dstart)
            """
           
            infoarq = open(info_file, 'r')
            infodata = infoarq.read()
            infoarq.close()
    
            info_temp = infodata.split('\n')
    
            # ... lendo data de inicio da simulacao
            info_date = info_temp[5]
            info_date = info_date.split(' ')
    
            lista = list()
            for i in range(len(info_date)):
                if info_date[i] == '':
                    lista.append(i)
        
            for j in reversed(lista):
                del info_date[j]
        
            dstart = datetime(int(info_date[2]), int(info_date[1]), int(info_date[0]), int(info_date[3]))
            
            # ... lendo nt e dt
            info_timestep = info_temp[8]
            info_timestep = info_timestep.split(' ')
    
            lista = list()
            for i in range(len(info_timestep)):
                if info_timestep[i] == '':
                    lista.append(i)
        
            for j in reversed(lista):
                del info_timestep[j]
        
            nt = info_timestep[0]
            dt = info_timestep[1]
            dt = dt.split(".")
            dt = dt[0]
    
            # ... lendo nc
            info_nc = info_temp[11]
            info_nc = info_nc.split(' ')
    
            lista = list()
            for i in range(len(info_nc)):
                if info_nc[i] == '':
                    lista.append(i)
        
            for j in reversed(lista):
                del info_nc[j]
        
            nc = info_nc[0]
    
            return int(nc), int(nt), int(dt), dstart

    # ... exemplo de aplicação:
        nc, nt, dt, dstart = le_infotudo(info_tudo_mgb)
        
#-------------------------- Armazenamento das datas simuladas --------------------------#

        dates = list()
        months = list()
        years = list()

        #print('Datas Simuladas:\n')
        time.sleep(3)
        for d in range(nt):
            delta = dstart + timedelta(days=d)
            year = delta.year
            month = delta.month
            years.append(year)
            months.append(month)
            dates.append(delta)
            #print('Ano: ' + str(year) + ' / Mês: ' + str(month) + ' / Data: ' + str(delta))

        dates = np.array(np.array(dates))
        #print('Período simulado: ' + str(dstart.date()) + ' - ' + str(delta.date()))
#----------- lendo o ano de início-----------------#
        h = dstart.strftime('%Y')
        hh = int(h)
        inicio2 = int(inicio)
        final2=int(final)
        i = delta.strftime('%Y')
        ii = int(i)
        k = math.floor(((inicio2-hh)/4))
        m = math.floor((final2-hh)/4)

        #--------------------hh e ii----------------#
        if (hh % 4) == 0:
            if (hh % 100) == 0:
                if (hh % 400) == 0:
                    o = 1
                else:
                    o = 0
            else:
                o = 1
        else:
            o = 0

        #------------------correto--------------#
        if (final2 % 4) == 0:
            if (final2 % 100) == 0:
                if (final2 % 400) == 0:
                    b = (((final2-hh)+1)*365)+m+o+1 #is a leap year
                else:
                    b = (((final2-hh)+1)*365)+m+o #is not a leap year
            else:
                b = (((final2-hh)+1)*365)+m+o+1 #is a leap year
        else:
            b = (((final2-hh)+1)*365)+m+o #is not a leap year
    
        if (inicio2 % 4) == 0:
            if (inicio2 % 100) == 0:
                if (inicio2 % 400) == 0:
                    f = (((inicio2-hh))*365)+k+o #is a leap year
                else:
                    f = (((inicio2-hh))*365)+k+o #is not leap year
            else:
                f = (((inicio2-hh))*365)+k+o #is a leap year
        else:
            f = (((inicio2-hh))*365)+k+o #is not leap year
   
#------------------- Leitura do arquivo de Precipitaação ------------------#

# ... funcao de leitura de binario

        def le_binario_mgb(filebin,nt,nc):
            """ read mgb binary files as numpy.array """
            return np.fromfile(filebin,'<f4').reshape(nt,nc)
        pre = le_binario_mgb(precipitacao_mgb, nt, nc)
        chuva = pre
        df_chuva = np.array(np.array(chuva))
        
        t =(final2-inicio2)+1
        
        def grafico (start,end):
    
            dias=end-start
              
            anole = pre[start:end]
            
            sano1e=np.sum(anole,axis=0)
            
            multanole2=areas2*sano1e
            
            sano1e2 = np.sum(multanole2)
            
            me = (sano1e2/somaareas)
            
            pano2 = (me/((dias)/365.25))
            
            return pano2

    
        arrayp = []
        
        for i in range(t-1):
            
            arrayp.append(grafico(f,b-(365*i)))        
            

        #------------plotando gráfico--------------#    
            
        y=[arrayp]
        
        x = list(range(1, t))
        
        
        # plotting points as a scatter plot
        plt.scatter(x, y, color= "blue", 
                    marker= ".", s=90)
          
        # x-axis label
        plt.xlabel('Simulation time (years)',fontsize=14)
        # frequency label
        plt.ylabel('Precipitation (mm)',fontsize=14)
        plt.yticks(fontsize=11)
        plt.xticks(fontsize=11)
        #plt.legend()
        plt.show()
        
    def graphesc(self):
        
        if self.dockwidget.radioButton.isChecked():
        
            dirMGB = ('C://mgb//')
            info_tudo_mgb= (dirMGB + 'Input\infoMGB.sim')
            evapotudo_mgb= (dirMGB + 'Output\EVAPTUDO_bin.MGB')
            precipitacao_mgb=(dirMGB + 'Input\CHUVABIN.PBI')
            vazao_mgb=(dirMGB +'Output\QITUDO_bin.MGB')
            mini_mgb=(dirMGB + 'Input\MINI.gtp')
            inicio=self.dockwidget.lineEdit_6.text()
            final=self.dockwidget.lineEdit_8.text()
        
        if self.dockwidget.radioButton_2.isChecked():
        
            #downDir = self.dockwidget.lineEdit.text()
            info_tudo_mgb=self.dockwidget.lineEdit_5.text()
            evapotudo_mgb=self.dockwidget.lineEdit_3.text()
            precipitacao_mgb=self.dockwidget.lineEdit.text()
            vazao_mgb=self.dockwidget.lineEdit_2.text()
            mini_mgb=self.dockwidget.lineEdit_7.text()
            inicio=self.dockwidget.lineEdit_6.text()
            final=self.dockwidget.lineEdit_8.text()

        def le_minigtp(mini_file):
            """ Le o arquivo MINI.gtp e armazena seus dados em um DataFrame """
    
        # ... leitura do arquivo "MINI.gtp"
            miniarq = open(mini_file, 'r')
            minidata = miniarq.read()
            miniarq.close()
            mini = minidata.split('\n')
    
        # .. gera listas para armazenar as informacoes de cada minibacia
            attbs = list()
            catchs = list()
            minis = list()
            xs = list()
            ys = list()
            subs = list()
            areas = list()
            uareas = list()
            rlens = list()
            rslos = list()
            alens = list()
            aslos = list()
            minijus = list()
            orders = list()
    
        # .. le o atributo CatID
            for i in range(1, len(mini)-1):
                catchs.append(int(mini[i][:8]))
    
        # .. le o atributo Mini
            for i in range(1, len(mini)-1):
                minis.append(int(mini[i][8:16]))
    
        # .. le o atributo Xcen
            for i in range(1, len(mini)-1):
                xs.append(float(mini[i][16:31]))
    
        # .. le o atributo Ycen
            for i in range(1, len(mini)-1):
                ys.append(float(mini[i][31:46]))
    
        # .. le o atributo Sub
            for i in range(1, len(mini)-1):
                subs.append(int(mini[i][46:54]))
    
        # .. le o atributo Area_(km2)
            for i in range(1, len(mini)-1):
                areas.append(float(mini[i][54:69]))
    
        # .. le o atributo AreaM_(km2)
            for i in range(1, len(mini)-1):
                uareas.append(float(mini[i][69:84]))
    
        # .. le o atributo Ltr_(km)
            for i in range(1, len(mini)-1):
                rlens.append(float(mini[i][84:99]))
    
        # .. le o atributo Str_(m/km)
            for i in range(1, len(mini)-1):
                rslos.append(float(mini[i][99:114]))
    
        # .. le o atributo Lrl_(km)
            for i in range(1, len(mini)-1):
                alens.append(float(mini[i][114:129]))
    
        # .. le o atributo Srl_(m/km)
            for i in range(1, len(mini)-1):
                aslos.append(float(mini[i][129:144]))
    
        # .. le o atributo MiniJus
            for i in range(1, len(mini)-1):
                minijus.append(int(mini[i][144:152]))
    
        # .. le o atributo Ordem
            for i in range(1, len(mini)-1):
                orders.append(int(mini[i][152:160]))
    
        # ... Armazena as informacoes de interesse em um dicionario
            mini_dict = {'Cat_ID' : catchs, 
                         'ID_Mini': minis,
                         'MiniJus': minijus,
                         'Sub'    : subs,
                         'Ordem'  : orders} # Pode-se adicionar as outras informacoes lidas do Mini.GTP seguindo a mesma logica
    
        # ... Cria uma matriz com os dados do dicionario
            df_mini = np.array(np.array(mini_dict))
            return df_mini, areas
  
    # ... aplicacao:
        df_mini, areas = le_minigtp(mini_mgb)
        areat = areas
        df_areat = np.array(np.array(areat))
        
        
    #-----soma da area total-----------#
        somaareas = np.sum(areat)
        #print ('Área total (km²):%.2f'% (somaareas))
        areas2 = np.array(areat)
        
        inicio=self.dockwidget.lineEdit_6.text()

        if inicio == "":
            msg = QMessageBox()
            msg.setIcon(QMessageBox.Critical)
            msg.setText("Please chose the period for simulation.")
            msg.exec_()
            return  
        
        final=self.dockwidget.lineEdit_8.text()
        
        if final == "":
            msg = QMessageBox()
            msg.setIcon(QMessageBox.Critical)
            msg.setText("Please chose the period for simulation.")
            msg.exec_()
            return  
        
        inicio2 = int(inicio)
        final2=int(final)
        
        def le_infotudo(info_file):
            """ Le infoMGB.sim para obter numero de minibacias (nc),
            numero de intervalos temporais (nt), tamanho do passo temporal (dt)
            e o primeiro dia de simulacao (dstart)
            """
           
            infoarq = open(info_file, 'r')
            infodata = infoarq.read()
            infoarq.close()
    
            info_temp = infodata.split('\n')
    
            # ... lendo data de inicio da simulacao
            info_date = info_temp[5]
            info_date = info_date.split(' ')
    
            lista = list()
            for i in range(len(info_date)):
                if info_date[i] == '':
                    lista.append(i)
        
            for j in reversed(lista):
                del info_date[j]
        
            dstart = datetime(int(info_date[2]), int(info_date[1]), int(info_date[0]), int(info_date[3]))
            
            # ... lendo nt e dt
            info_timestep = info_temp[8]
            info_timestep = info_timestep.split(' ')
    
            lista = list()
            for i in range(len(info_timestep)):
                if info_timestep[i] == '':
                    lista.append(i)
        
            for j in reversed(lista):
                del info_timestep[j]
        
            nt = info_timestep[0]
            dt = info_timestep[1]
            dt = dt.split(".")
            dt = dt[0]
    
            # ... lendo nc
            info_nc = info_temp[11]
            info_nc = info_nc.split(' ')
    
            lista = list()
            for i in range(len(info_nc)):
                if info_nc[i] == '':
                    lista.append(i)
        
            for j in reversed(lista):
                del info_nc[j]
        
            nc = info_nc[0]
    
            return int(nc), int(nt), int(dt), dstart

    # ... exemplo de aplicação:
        nc, nt, dt, dstart = le_infotudo(info_tudo_mgb)
        
#-------------------------- Armazenamento das datas simuladas --------------------------#

        dates = list()
        months = list()
        years = list()

        #print('Datas Simuladas:\n')
        time.sleep(3)
        for d in range(nt):
            delta = dstart + timedelta(days=d)
            year = delta.year
            month = delta.month
            years.append(year)
            months.append(month)
            dates.append(delta)
            #print('Ano: ' + str(year) + ' / Mês: ' + str(month) + ' / Data: ' + str(delta))

        dates = np.array(np.array(dates))
        #print('Período simulado: ' + str(dstart.date()) + ' - ' + str(delta.date()))
#----------- lendo o ano de início-----------------#
        h = dstart.strftime('%Y')
        hh = int(h)
        inicio2 = int(inicio)
        final2=int(final)
        i = delta.strftime('%Y')
        ii = int(i)
        k = math.floor(((inicio2-hh)/4))
        m = math.floor((final2-hh)/4)

        #--------------------hh e ii----------------#
        if (hh % 4) == 0:
            if (hh % 100) == 0:
                if (hh % 400) == 0:
                    o = 1
                else:
                    o = 0
            else:
                o = 1
        else:
            o = 0

        #------------------correto--------------#
        if (final2 % 4) == 0:
            if (final2 % 100) == 0:
                if (final2 % 400) == 0:
                    b = (((final2-hh)+1)*365)+m+o+1 #is a leap year
                else:
                    b = (((final2-hh)+1)*365)+m+o #is not a leap year
            else:
                b = (((final2-hh)+1)*365)+m+o+1 #is a leap year
        else:
            b = (((final2-hh)+1)*365)+m+o #is not a leap year
    
        if (inicio2 % 4) == 0:
            if (inicio2 % 100) == 0:
                if (inicio2 % 400) == 0:
                    f = (((inicio2-hh))*365)+k+o #is a leap year
                else:
                    f = (((inicio2-hh))*365)+k+o #is not leap year
            else:
                f = (((inicio2-hh))*365)+k+o #is a leap year
        else:
            f = (((inicio2-hh))*365)+k+o #is not leap year
   
        
#------------------- Leitura do arquivo de Evapotranspiração ------------------#

# ... funcao de leitura de binario

        def le_binario_mgb(filebin,nt,nc):
            """ read mgb binary files as numpy.array """
            return np.fromfile(filebin,'<f4').reshape(nt,nc)
        qi = le_binario_mgb(vazao_mgb, nt, nc)
        vazao = qi
        df_vazao = np.array(np.array(vazao))
  
        t =(final2-inicio2)+1
        
        def grafico (start,end):
    
            dias=end-start
              
            anole = qi[start:end]
            
            sano1e=np.sum(anole,axis=0)
            
            array_lengthq4 = len(sano1e)
            
            last_elementq4 = sano1e[array_lengthq4 -1]
            
            conversaoq4 = ((31536*last_elementq4)/somaareas)
            
            somaanualq4 = (conversaoq4/((dias)/365.25))
            
            return somaanualq4

    
        arraye = []
        
        for i in range(t-1):
            
            arraye.append(grafico(f,b-(365*i)))        
            

        #------------plotando gráfico--------------#    
            
        y=[arraye]
        compe = len(arraye)
        
        x = list(range(1, t))
        
        
        # plotting points as a scatter plot
        plt.scatter(x, y, color= "blue", 
                    marker= ".", s=90)
          
        # x-axis label
        plt.xlabel('Simulation time (years)',fontsize=14)
        # frequency label
        plt.ylabel('Discharge (mm)',fontsize=14)
        #plt.legend()
        plt.yticks(fontsize=11)
        plt.xticks(fontsize=11)
        plt.show()
    
    def graphds(self):
        if self.dockwidget.radioButton.isChecked():
        
            dirMGB = ('C://mgb//')
            info_tudo_mgb= (dirMGB + 'Input\infoMGB.sim')
            evapotudo_mgb= (dirMGB + 'Output\EVAPTUDO_bin.MGB')
            precipitacao_mgb=(dirMGB + 'Input\CHUVABIN.PBI')
            vazao_mgb=(dirMGB +'Output\QITUDO_bin.MGB')
            mini_mgb=(dirMGB + 'Input\MINI.gtp')
            inicio=self.dockwidget.lineEdit_6.text()
            final=self.dockwidget.lineEdit_8.text()
        
        if self.dockwidget.radioButton_2.isChecked():
        
            #downDir = self.dockwidget.lineEdit.text()
            info_tudo_mgb=self.dockwidget.lineEdit_5.text()
            evapotudo_mgb=self.dockwidget.lineEdit_3.text()
            precipitacao_mgb=self.dockwidget.lineEdit.text()
            vazao_mgb=self.dockwidget.lineEdit_2.text()
            mini_mgb=self.dockwidget.lineEdit_7.text()
            inicio=self.dockwidget.lineEdit_6.text()
            final=self.dockwidget.lineEdit_8.text()

        
        def le_minigtp(mini_file):
            """ Le o arquivo MINI.gtp e armazena seus dados em um DataFrame """
    
        # ... leitura do arquivo "MINI.gtp"
            miniarq = open(mini_file, 'r')
            minidata = miniarq.read()
            miniarq.close()
            mini = minidata.split('\n')
    
        # .. gera listas para armazenar as informacoes de cada minibacia
            attbs = list()
            catchs = list()
            minis = list()
            xs = list()
            ys = list()
            subs = list()
            areas = list()
            uareas = list()
            rlens = list()
            rslos = list()
            alens = list()
            aslos = list()
            minijus = list()
            orders = list()
    
        # .. le o atributo CatID
            for i in range(1, len(mini)-1):
                catchs.append(int(mini[i][:8]))
    
        # .. le o atributo Mini
            for i in range(1, len(mini)-1):
                minis.append(int(mini[i][8:16]))
    
        # .. le o atributo Xcen
            for i in range(1, len(mini)-1):
                xs.append(float(mini[i][16:31]))
    
        # .. le o atributo Ycen
            for i in range(1, len(mini)-1):
                ys.append(float(mini[i][31:46]))
    
        # .. le o atributo Sub
            for i in range(1, len(mini)-1):
                subs.append(int(mini[i][46:54]))
    
        # .. le o atributo Area_(km2)
            for i in range(1, len(mini)-1):
                areas.append(float(mini[i][54:69]))
    
        # .. le o atributo AreaM_(km2)
            for i in range(1, len(mini)-1):
                uareas.append(float(mini[i][69:84]))
    
        # .. le o atributo Ltr_(km)
            for i in range(1, len(mini)-1):
                rlens.append(float(mini[i][84:99]))
    
        # .. le o atributo Str_(m/km)
            for i in range(1, len(mini)-1):
                rslos.append(float(mini[i][99:114]))
    
        # .. le o atributo Lrl_(km)
            for i in range(1, len(mini)-1):
                alens.append(float(mini[i][114:129]))
    
        # .. le o atributo Srl_(m/km)
            for i in range(1, len(mini)-1):
                aslos.append(float(mini[i][129:144]))
    
        # .. le o atributo MiniJus
            for i in range(1, len(mini)-1):
                minijus.append(int(mini[i][144:152]))
    
        # .. le o atributo Ordem
            for i in range(1, len(mini)-1):
                orders.append(int(mini[i][152:160]))
    
        # ... Armazena as informacoes de interesse em um dicionario
            mini_dict = {'Cat_ID' : catchs, 
                         'ID_Mini': minis,
                         'MiniJus': minijus,
                         'Sub'    : subs,
                         'Ordem'  : orders} # Pode-se adicionar as outras informacoes lidas do Mini.GTP seguindo a mesma logica
    
        # ... Cria uma matriz com os dados do dicionario
            df_mini = np.array(np.array(mini_dict))
            return df_mini, areas
  
    # ... aplicacao:
        df_mini, areas = le_minigtp(mini_mgb)
        areat = areas
        df_areat = np.array(np.array(areat))
        
        
    #-----soma da area total-----------#
        somaareas = np.sum(areat)
        #print ('Área total (km²):%.2f'% (somaareas))
        areas2 = np.array(areat)
        
        inicio=self.dockwidget.lineEdit_6.text()

        if inicio == "":
            msg = QMessageBox()
            msg.setIcon(QMessageBox.Critical)
            msg.setText("Please chose the period for simulation.")
            msg.exec_()
            return  
        
        final=self.dockwidget.lineEdit_8.text()
        
        if final == "":
            msg = QMessageBox()
            msg.setIcon(QMessageBox.Critical)
            msg.setText("Please chose the period for simulation.")
            msg.exec_()
            return  
        
        inicio2 = int(inicio)
        final2=int(final)
        
        def le_infotudo(info_file):
            """ Le infoMGB.sim para obter numero de minibacias (nc),
            numero de intervalos temporais (nt), tamanho do passo temporal (dt)
            e o primeiro dia de simulacao (dstart)
            """
           
            infoarq = open(info_file, 'r')
            infodata = infoarq.read()
            infoarq.close()
    
            info_temp = infodata.split('\n')
    
            # ... lendo data de inicio da simulacao
            info_date = info_temp[5]
            info_date = info_date.split(' ')
    
            lista = list()
            for i in range(len(info_date)):
                if info_date[i] == '':
                    lista.append(i)
        
            for j in reversed(lista):
                del info_date[j]
        
            dstart = datetime(int(info_date[2]), int(info_date[1]), int(info_date[0]), int(info_date[3]))
            
            # ... lendo nt e dt
            info_timestep = info_temp[8]
            info_timestep = info_timestep.split(' ')
    
            lista = list()
            for i in range(len(info_timestep)):
                if info_timestep[i] == '':
                    lista.append(i)
        
            for j in reversed(lista):
                del info_timestep[j]
        
            nt = info_timestep[0]
            dt = info_timestep[1]
            dt = dt.split(".")
            dt = dt[0]
    
            # ... lendo nc
            info_nc = info_temp[11]
            info_nc = info_nc.split(' ')
    
            lista = list()
            for i in range(len(info_nc)):
                if info_nc[i] == '':
                    lista.append(i)
        
            for j in reversed(lista):
                del info_nc[j]
        
            nc = info_nc[0]
    
            return int(nc), int(nt), int(dt), dstart

    # ... exemplo de aplicação:
        nc, nt, dt, dstart = le_infotudo(info_tudo_mgb)
        
#-------------------------- Armazenamento das datas simuladas --------------------------#

        dates = list()
        months = list()
        years = list()

        #print('Datas Simuladas:\n')
        time.sleep(3)
        for d in range(nt):
            delta = dstart + timedelta(days=d)
            year = delta.year
            month = delta.month
            years.append(year)
            months.append(month)
            dates.append(delta)
            #print('Ano: ' + str(year) + ' / Mês: ' + str(month) + ' / Data: ' + str(delta))

        dates = np.array(np.array(dates))
        #print('Período simulado: ' + str(dstart.date()) + ' - ' + str(delta.date()))
#----------- lendo o ano de início-----------------#
        h = dstart.strftime('%Y')
        hh = int(h)
        inicio2 = int(inicio)
        final2=int(final)
        i = delta.strftime('%Y')
        ii = int(i)
        k = math.floor(((inicio2-hh)/4))
        m = math.floor((final2-hh)/4)

        #--------------------hh e ii----------------#
        if (hh % 4) == 0:
            if (hh % 100) == 0:
                if (hh % 400) == 0:
                    o = 1
                else:
                    o = 0
            else:
                o = 1
        else:
            o = 0

        #------------------correto--------------#
        if (final2 % 4) == 0:
            if (final2 % 100) == 0:
                if (final2 % 400) == 0:
                    b = (((final2-hh)+1)*365)+m+o+1 #is a leap year
                else:
                    b = (((final2-hh)+1)*365)+m+o #is not a leap year
            else:
                b = (((final2-hh)+1)*365)+m+o+1 #is a leap year
        else:
            b = (((final2-hh)+1)*365)+m+o #is not a leap year
    
        if (inicio2 % 4) == 0:
            if (inicio2 % 100) == 0:
                if (inicio2 % 400) == 0:
                    f = (((inicio2-hh))*365)+k+o #is a leap year
                else:
                    f = (((inicio2-hh))*365)+k+o #is not leap year
            else:
                f = (((inicio2-hh))*365)+k+o #is a leap year
        else:
            f = (((inicio2-hh))*365)+k+o #is not leap year
            
        def le_binario_mgb(filebin,nt,nc):
            """ read mgb binary files as numpy.array """
            return np.fromfile(filebin,'<f4').reshape(nt,nc)
        qi = le_binario_mgb(vazao_mgb, nt, nc)
        vazao = qi
        df_vazao = np.array(np.array(vazao))
  
        
        def le_binario_mgb(filebin,nt,nc):
            """ read mgb binary files as numpy.array """
            return np.fromfile(filebin,'<f4').reshape(nt,nc)
        et = le_binario_mgb(evapotudo_mgb, nt, nc)
        evap = et
        df_evap = np.array(np.array(evap))
        

        # ... funcao de leitura de binario
        def le_binario_mgbp(filebin,nt,nc):
            """ read mgb binary files as numpy.array """
            return np.fromfile(filebin,'<f4').reshape(nt,nc)
        pre = le_binario_mgb(precipitacao_mgb, nt, nc)
        chuva = pre
        df_chuva = np.array(np.array(chuva))
  
        t =(final2-inicio2)+1
        
        def grafico (start,end):
            
            dias=end-start
                      
            anole = et[start:end]
                    
            sano1e=np.sum(anole,axis=0)
                    
            multanole2=areas2*sano1e
                    
            sano1e2 = np.sum(multanole2)
                    
            me = (sano1e2/somaareas)
                    
            etano2 = (me/((dias)/365.25))
                    
            return etano2
        
        #--------------adicionando funcionalidades pro grafico----------------
            
        arraye = []
        
        for i in range(t-1):
            
            arraye.append(grafico(f,b-(365*i))) # 1996-2000         
    

        def grafico2 (start,end):
            
            dias=end-start
              
            anole = pre[start:end]
            
            sano1e=np.sum(anole,axis=0)
            
            multanole2=areas2*sano1e
            
            sano1e2 = np.sum(multanole2)
            
            me = (sano1e2/somaareas)
            
            pano2 = (me/((dias)/365.25))
            
            return pano2
        
        #--------------adicionando funcionalidades pro grafico----------------
            
        arrayp = []
        
        for i in range(t-1):
            
            arrayp.append(grafico2(f,b-(365*i))) # 1996-2000
             
            
        def grafico3 (start,end):
            
            dias=end-start
              
            anole = qi[start:end]
            
            sano1e=np.sum(anole,axis=0)
            
            array_lengthq4 = len(sano1e)
            
            last_elementq4 = sano1e[array_lengthq4 -1]
            
            conversaoq4 = ((31536*last_elementq4)/somaareas)
            
            somaanualq4 = (conversaoq4/((dias)/365.25))
            
            return somaanualq4
            
        
        #--------------adicionando funcionalidades pro grafico----------------
            
        arrayq = []
        
        for i in range(t-1):
            
            arrayq.append(grafico3(f,b-(365*i))) # 1996-2000     
        #------------ plota    
        pp = [x-y-z for x,y,z in zip(arrayp, arraye, arrayq)]
        pp2 = [x/y for x,y in zip(pp, arrayp)]
        pp3 = [element *100 for element in pp2]
        pp4 = [abs(element) for element in pp3]
        pp5 = pp4.reverse();
        
        y=[pp4]
        #compe = len(arraye)
        
        x = list(range(1, t))
        
        
        # plotting points as a scatter plot
        plt.scatter(x, y, color= "blue", 
                    marker= ".", s=90)
          
        # x-axis label
        plt.xlabel('Simulation time (years)',fontsize=14)
        # frequency label
        plt.ylabel('dS/P (%)',fontsize=14)
        # plot title
        #plt.title('Evaporação')
        # showing legend
        #plt.grid(True)
        #plt.legend()
        #plt.plot(x,y,"ro", color= "grey")
        # function to show the plot
        plt.yticks(fontsize=11)
        plt.xticks(fontsize=11)
        plt.show()
        
    def run(self):

        if not self.pluginIsActive:
            self.pluginIsActive = True
            self.dockwidget.closingPlugin.connect(self.onClosePlugin)
            self.iface.addDockWidget(Qt.RightDockWidgetArea, self.dockwidget)
            self.dockwidget.show()
            
